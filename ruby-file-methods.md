# Ruby File 类和方法


_File_ 表示一个连接到普通文件的 _stdio_ 对象。open 为普通文件返回该类的一个实例。


## 类方法
<table > <tr><th style="width:5%">序号</th><th>方法 & 描述</th></tr> <tr><td>1</td><td><b>File::atime( path)</b><br />返回 <i>path</i> 的最后访问时间。</td></tr> <tr><td>2</td><td><b>File::basename( path[, suffix])</b><br />返回 <i>path</i> 末尾的文件名。如果指定了 <i>suffix</i>，则它会从文件名末尾被删除。<br /> 例如：File.basename("/home/users/bin/ruby.exe") #=> "ruby.exe"</td></tr> <tr><td>3</td><td><b>File::blockdev?( path)</b><br />如果 path 是一个块设备，则返回 true。</td></tr> <tr><td>4</td><td><b>File::chardev?( path)</b><br />如果 path 是一个字符设备，则返回 true。</td></tr> <tr><td>5</td><td><b>File::chmod( mode, path...)</b><br />改变指定文件的权限模式。</td></tr> <tr><td>6</td><td><b>File::chown( owner, group, path...)</b><br />改变指定文件的所有者和所属组。</td></tr> <tr><td>7</td><td><b>File::ctime( path)</b><br />返回 path 的最后一个 inode 更改时间。</td></tr> <tr><td>8</td><td><b>File::delete( path...)<br /> File::unlink( path...)</b><br />删除指定的文件。</td></tr> <tr><td>9</td><td><b>File::directory?( path)</b><br />如果 path 是一个目录，则返回 true。</td></tr> <tr><td>10</td><td><b>File::dirname( path)</b><br />返回 path 的目录部分，不包括最后的文件名。</td></tr> <tr><td>11</td><td><b>File::executable?( path)</b><br />如果 path 是可执行的，则返回 true。</td></tr> <tr><td>12</td><td><b>File::executable_real?( path)</b><br />如果 path 通过真正的用户权限是可执行的，则返回 true。</td></tr> <tr><td>13</td><td><b>File::exist?( path)</b><br />如果 path 存在，则返回 true。</td></tr> <tr><td>1</td><td><b>File::expand_path( path[, dir])</b><br />返回 path 的绝对路径，扩展 ~ 为进程所有者的主目录，~user 为用户的主目录。相对路径是相对于 dir 指定的目录，如果 dir 被省略则相对于当前工作目录。</td></tr> <tr><td>14</td><td><b>File::file?( path)</b><br />如果 path 是一个普通文件，则返回 true。</td></tr> <tr><td>15</td><td><b>File::ftype( path)</b><br />返回下列其中一个字符串，表示文件类型： <ul > <li><b>file</b> - 普通文件</li> <li><b>directory</b> - 目录</li> <li><b>characterSpecial</b> - 字符特殊文件</li> <li><b>blockSpecial</b> - 块特殊文件</li> <li><b>fifo</b> - 命名管道（FIFO）</li> <li><b>link</b> - 符号链接</li> <li><b>socket</b> - Socket</li> <li><b>unknown</b> - 未知的文件类型</li> </ul> </td></tr> <tr><td>16</td><td><b>File::grpowned?( path)</b><br />如果 path 由用户的所属组所有，则返回 true。</td></tr> <tr><td>17</td><td><b>File::join( item...)</b><br />返回一个字符串，由指定的项连接在一起，并使用 File::Separator 进行分隔。<br /> 例如：File::join("", "home", "usrs", "bin") # => "/home/usrs/bin"</td></tr> <tr><td>18</td><td><b>File::link( old, new)</b><br />创建一个到文件 old 的硬链接。</td></tr> <tr><td>19</td><td><b>File::lstat( path)</b><br />与 stat 相同，但是它返回自身符号链接上的信息，而不是所指向的文件。</td></tr> <tr><td>20</td><td><b>File::mtime( path)</b><br />返回 path 的最后一次修改时间。</td></tr> <tr><td>21</td><td><b>File::new( path[, mode="r"])<br /> File::open( path[, mode="r"])<br /> File::open( path[, mode="r"]) {|f| ...}</b><br />打开文件。如果指定了块，则通过传递新文件作为参数来执行块。当块退出时，文件会自动关闭。这些方法有别于 Kernel.open，即使 path 是以 | 开头，后续的字符串也不会作为命令运行。</td></tr> <tr><td>22</td><td><b>File::owned?( path)</b><br />如果 path 由有效的用户所有，则返回 true。</td></tr> <tr><td>23</td><td><b>File::pipe?( path)</b><br />如果 path 是一个管道，则返回 true。</td></tr> <tr><td>24</td><td><b>File::readable?( path)</b><br />如果 path 是可读的，则返回 true。</td></tr> <tr><td>25</td><td><b>File::readable_real?( path)</b><br />如果 path 通过真正的用户权限是可读的，则返回 true。</td></tr> <tr><td>25</td><td><b>File::readlink( path)</b><br />返回 path 所指向的文件。</td></tr> <tr><td>26</td><td><b>File::rename( old, new)</b><br />改变文件名 old 为 new。</td></tr> <tr><td>27</td><td><b>File::setgid?( path)</b><br />如果设置了 path 的 set-group-id 权限位，则返回 true。</td></tr> <tr><td>28</td><td><b>File::setuid?( path)</b><br />如果设置了 path 的 set-user-id 权限位，则返回 true。</td></tr> <tr><td>29</td><td><b>File::size( path)</b><br />返回 path 的文件大小。</td></tr> <tr><td>30</td><td><b>File::size?( path)</b><br />返回 path 的文件大小，如果为 0 则返回 nil。</td></tr> <tr><td>31</td><td><b>File::socket?( path)</b><br />如果 path 是一个 socket，则返回 true。</td></tr> <tr><td>32</td><td><b>File::split( path)</b><br />返回一个数组，包含 path 的内容，path 被分成 File::dirname(path) 和 File::basename(path)。</td></tr> <tr><td>33</td><td><b>File::stat( path)</b><br />返回 path 上带有信息的 File::Stat 对象。</td></tr> <tr><td>34</td><td><b>File::sticky?( path)</b><br />如果设置了 path 的 sticky 位，则返回 true。</td></tr> <tr><td>35</td><td><b>File::symlink( old, new)</b><br />创建一个指向文件 old 的符号链接。</td></tr> <tr><td>36</td><td><b>File::symlink?( path)</b><br />如果 path 是一个符号链接，则返回 true。</td></tr> <tr><td>37</td><td><b>File::truncate( path, len)</b><br />截断指定的文件为 len 字节。</td></tr> <tr><td>38</td><td><b>File::unlink( path...)</b><br />删除 path 给定的文件。</td></tr> <tr><td>39</td><td><b>File::umask([ mask])</b><br />如果未指定参数，则为该进程返回当前的 umask。如果指定了一个参数，则设置了 umask，并返回旧的 umask。</td></tr> <tr><td>40</td><td><b>File::utime( atime, mtime, path...)</b><br />改变指定文件的访问和修改时间。</td></tr> <tr><td>41</td><td><b>File::writable?( path)</b><br />如果 path 是可写的，则返回 true。</td></tr> <tr><td>42</td><td><b>File::writable_real?( path)</b><br />如果 path 通过真正的用户权限是可写的，则返回 true。</td></tr> <tr><td>43</td><td><b>File::zero?( path)</b><br />如果 path 的文件大小是 0，则返回 true。</td></tr> </table> 

## 实例方法

假设 **f** 是 **File** 类的一个实例：

</p> <table > <tr><th style="width:5%">序号</th><th>方法 & 描述</th></tr> <tr><td>1</td><td><b>f.atime</b><br />返回 f 的最后访问时间。</td></tr> <tr><td>2</td><td><b>f.chmode( mode)</b><br />改变 f 的权限模式。</td></tr> <tr><td>3</td><td><b>f.chown( owner, group)</b><br />改变 f 的所有者和所属组。</td></tr> <tr><td>4</td><td><b>f.ctime</b><br />返回 f 的最后一个 inode 更改时间。</td></tr> <tr><td>5</td><td><b>f.flock( op)</b><br />调用 flock(2)。op 可以是 0 或一个逻辑值或 File 类常量 LOCK_EX、LOCK_NB、LOCK_SH 和 LOCK_UN。</td></tr> <tr><td>6</td><td><b>f.lstat</b><br />与 stat 相同，但是它返回自身符号链接上的信息，而不是所指向的文件。</td></tr> <tr><td>7</td><td><b>f.mtime</b><br />返回 f 的最后修改时间。</td></tr> <tr><td>8</td><td><b>f.path</b><br />返回用于创建 f 的路径名。</td></tr> <tr><td>9</td><td><b>f.reopen( path[, mode="r"])</b><br />重新打开文件。</td></tr> <tr><td>10</td><td><b>f.truncate( len)</b><br />截断 f 为 len 字节。</td></tr> </table> 